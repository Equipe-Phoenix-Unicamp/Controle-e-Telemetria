/*******************************************************************************
**  DAVE App Name : CNT001       App Version: 1.0.24               
**  This file is generated by DAVE, User modification to this file will be    **
**  overwritten at the next code generation.                                  **
*******************************************************************************/


/*CODE_BLOCK_BEGIN[CNT001.c]*/

/*******************************************************************************
 Copyright (c) 2014, Infineon Technologies AG                                 **
 All rights reserved.                                                         **
                                                                              **
 Redistribution and use in source and binary forms, with or without           **
 modification,are permitted provided that the following conditions are met:   **
                                                                              **
 *Redistributions of source code must retain the above copyright notice,      **
 this list of conditions and the following disclaimer.                        **
 *Redistributions in binary form must reproduce the above copyright notice,   **
 this list of conditions and the following disclaimer in the documentation    **
 and/or other materials provided with the distribution.                       **
 *Neither the name of the copyright holders nor the names of its contributors **
 may be used to endorse or promote products derived from this software without**
 specific prior written permission.                                           **
                                                                              **
 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  **
 AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    **
 IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   **
 ARE  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   **
 LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         **
 CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF         **
 SUBSTITUTE GOODS OR  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    **
 INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN      **
 CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)       **
 ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   **
 POSSIBILITY OF SUCH DAMAGE.                                                  **
                                                                              **
 To improve the quality of the software, users are encouraged to share        **
 modifications, enhancements or bug fixes with Infineon Technologies AG       **
 dave@infineon.com).                                                          **
                                                                              **
********************************************************************************
**                                                                            **
**                                                                            **
** PLATFORM : Infineon XMC4000/XMC1000 Series                                 **
**                                                                            **
** COMPILER : Compiler Independent                                            **
**                                                                            **
** AUTHOR   : DAVE App Developer                                              **
**                                                                            **
** MAY BE CHANGED BY USER [yes/no]: Yes                                       **
**                                                                            **
** MODIFICATION DATE : Jan 24, 2014                                           **
*******************************************************************************/


/**
 * @file CNT001.c
 *
 * @brief This file contains CCU4_EventCounter_CNT001 App API definitions
 * This app counts the number of events. Event could be the rising edge or
 * falling edge or both edges of the input signal.
 * Input signal can be given through GPIO or any other peripheral like ERU,
 * CCU4,8
 */

/* Revision History	
 * 01 Nov 2012   v1.0.12   Taken as a base version														     
 * 10 Dec 2012   v1.0.14   DBG002 Macros are added
 * 07 Feb 2013 	 v1.0.16   Repetitive Status updation in Event APIs is removed
 * 23 Jan 2014   v1.0.22   Error codes are added in various functions, that can 
 *                         be logged with DBG002 App.				   
 */

/******************************************************************************
 **                      Author(s) Identity                                   **
 *******************************************************************************
 **                                                                           **
 ** Initials     Name                                                         **
 ** SK           DAVE App Developer                                           **
 ** --------------------------------------------------------------------------**

 *******************************************************************************/

/*******************************************************************************
 ** INCLUDE FILES                                                             **
 *******************************************************************************/
#include <DAVE3.h>
#include "../../inc/CNT001/CNT001.h"

  
/*****************************************************************************
              DUMMY DEFINTIONS OF DEBUG LOG MACROS
*****************************************************************************/
/*These definitions are included here to avoid compilation errors,
 since the DBG002 app is not part of the project. All the macros are defined
 as empty*/ 
#ifndef _DBG002_H_

#define DBG002_RegisterCallBack(A,B,C)
#define DBG002_I(e) 
#define DBG002_IG(e,g) 
#define DBG002_IH(e,h) 
#define DBG002_IP(e,p) 
#define DBG002_IGH(e,g,h) 
#define DBG002_IGP(e,g,p) 
#define DBG002_IHP(e,h,p) 
#define DBG002_IGHP(e,g,h,p) 
#define DBG002_N(e) 
#define DBG002_NG(e,g) 
#define DBG002_NH(e,h) 
#define DBG002_NP(e,p) 
#define DBG002_NGH(e,g,h) 
#define DBG002_NGP(e,g,p) 
#define DBG002_NHP(e,h,p) 
#define DBG002_NGHP(e,g,h,p) 
#define DBG002_ID(e) 
#define DBG002_IS(e) 
#define DBG002_ISG(e,g) 
#define DBG002_SAFETY_CRITICAL(groupid,messageid,length,value)
#define DBG002_CRITICAL(groupid,messageid,length,value)
#define DBG002_ERROR(groupid,messageid,length,value)
#define DBG002_WARNING(groupid,messageid,length,value)
#define DBG002_INFO(groupid,messageid,length,value)
#define DBG002_TRACE(groupid,messageid,length,value)
#define DBG002_FUNCTION_ENTRY(GID, Status) 
#define DBG002_FUNCTION_EXIT(GID, Status) 
#define DBG002_MESSAGEID_LITERAL 
#endif/* End of defintions of dummy Debug Log macros*/                  

#define APP_GID DBG002_GID_CNT001

#define CNT001_STATUS_LEN 4U
/*******************************************************************************
 **                      Private Type Definitions                             **
 ******************************************************************************/

/*******************************************************************************
 **                 Private Function Declarations:
 ******************************************************************************/
/**
 * @brief This function initializes the app.
 *
 * @param [in] HandlePtr pointer to the Instance variable<BR>
 *
 * @return  NOne <BR>
 *
 * <b>Reentrancy:  Yes</b><BR>
 * <b>Sync/Async:  Synchronous</b><BR>
 */

status_t CNT001_lInit(const CNT001_HandleType *HandlePtr );

/*******************************************************************************
 **                      Global Constant Definitions                          **
 ******************************************************************************/

/*******************************************************************************
 **                      Global Variable Definitions                          **
 ******************************************************************************/

/*******************************************************************************
 **                      Private Constant Definitions                         **
 ******************************************************************************/

/*******************************************************************************
 **                 Function like macro definitions                           **
 ******************************************************************************/

/*******************************************************************************
 **                      Private Function Definitions                         **
 ******************************************************************************/

/*******************************************************************************
 **                      Public Function Definitions                          **
 ******************************************************************************/
/**
 * @cond INTERNAL_DOCS
 */


/** This function initializes the app */
void CNT001_Init(void)
{
  status_t status = (uint32_t)CNT001_OPER_NOT_ALLOWED_ERROR;


  CCU4GLOBAL_Init();
  status = CNT001_lInit( &CNT001_Handle0);
    
    /* Start the app if "Start after initialization" is selected */
  if(status == (uint32_t)DAVEApp_SUCCESS)
  {
	DBG002_N(status != DAVEApp_SUCCESS);
    if(CNT001_Handle0.StartControl == (uint8_t)SET)
    {
      status = CNT001_Start( &CNT001_Handle0);
	  DBG002_N(status != DAVEApp_SUCCESS);
    }
  }
  else
  {
	 DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, CNT001_STATUS_LEN, &status);
  }
}

/* This Function initializes the CCU4_CCy slice and the App. Local function
 *  is used to initialize all the instances of the app.
 */
status_t CNT001_lInit(const CNT001_HandleType *HandlePtr )
{

  status_t status = (uint32_t)CNT001_OPER_NOT_ALLOWED_ERROR;

  CCU4_CC4_TypeDef *CCU4Ptr;          /*Pointer to the CCU4 Structure */

  CCU4_GLOBAL_TypeDef *CCU4KernelPtr; /* Pointer to the CCU4 Kernel Structure */
  CCU4Ptr = HandlePtr->CC4Ptr;
  CCU4KernelPtr = HandlePtr->CC4KernalPtr;
  DBG002_FUNCTION_ENTRY(APP_GID, (uint32_t)CNT001_FUNCTION_ENTRY);

  do
  {
    /*<<<DD_CNT001_API_1_1>>>*/

    if (HandlePtr->DynamicHandlePtr->State != CNT001_UNINITIALIZED)
    {
      DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, CNT001_STATUS_LEN, &status);
      break;
    }/* End of "if(HandlePtr->DynamicHandlePtr->State != CNT001_UNINITIALIZED)"*/

    /*<<<DD_CNT001_API_1_2>>>*/
    /* Set the Input Selector Register */
    /* Step1: Clear the  EV0EM & LPF0M bit fields */
    CCU4Ptr->INS &= (uint32_t)~((CCU4_CC4_INS_EV0EM_Msk )| \
        (uint32_t)(CCU4_CC4_INS_LPF0M_Msk ) \
    );
    /*Step2: Set the Bit */
    CCU4Ptr->INS |= (uint32_t)((((uint32_t)HandlePtr->CountingEventEdge <<
        CCU4_CC4_INS_EV0EM_Pos)& (uint32_t)CCU4_CC4_INS_EV0EM_Msk) | \
        (((uint32_t)HandlePtr->Lpf   << \
            CCU4_CC4_INS_LPF0M_Pos)& (uint32_t)CCU4_CC4_INS_LPF0M_Msk)
    );

    /* Set CNT001_EVENT0 as External Counting function in CMC Register*/
    WR_REG(CCU4Ptr->CMC, (uint32_t)CCU4_CC4_CMC_CNTS_Msk,\
	                   (uint32_t)CCU4_CC4_CMC_CNTS_Pos,(uint32_t)CNT001_EVENT0);

    /* If Gating enabled , Set CNT001_EVENT1 as external gating signal*/
    if (HandlePtr->ExternalGatingSignal)
    {
      CCU4Ptr->INS |= (((uint32_t)HandlePtr->GatingLevel  << CCU4_CC4_INS_EV1LM_Pos )\
          & (uint32_t)CCU4_CC4_INS_EV1LM_Msk);
      CCU4Ptr->CMC |= (((uint32_t)CNT001_EVENT1  << CCU4_CC4_CMC_GATES_Pos)\
          & (uint32_t)CCU4_CC4_CMC_GATES_Msk);
      if((uint32_t)HandlePtr->GatingLevel == (uint8_t)RESET)
      {
        CCU4Ptr->INS |= (((uint32_t)0x01  << CCU4_CC4_INS_EV1EM_Pos )\
            & (uint32_t)CCU4_CC4_INS_EV1EM_Msk);
      }
      else
      {
        CCU4Ptr->INS |= (((uint32_t)0x02  << CCU4_CC4_INS_EV1EM_Pos )\
            & (uint32_t)CCU4_CC4_INS_EV1EM_Msk);
      }
    }/*End of "if( HandlePtr->ExternalGatingSignal)" */

    /* Clear the Timer Values( DITC, TCC, TRBC bit fields in TCCLR Register ) */
    CCU4Ptr->TCCLR |= CNT001_CCU4_TCCLR_CLEAR;

    /* Set edge-aligned mode in the TC Register */
    WR_REG(CCU4Ptr->TC,(uint32_t)CCU4_CC4_TC_TCM_Msk,\
	         (uint32_t)CCU4_CC4_TC_TCM_Pos,(uint32_t)CNT001_EDGE_ALIGNED_MODE );

    /*Set Compare register value with the user defined value */
    WR_REG(CCU4Ptr->CRS, (uint32_t)CCU4_CC4_CRS_CRS_Msk,\
	           (uint32_t)CCU4_CC4_CRS_CRS_Pos, (uint32_t)HandlePtr->CountMatch);

    /* Set Period register Value as maximum*/
    WR_REG(CCU4Ptr->PRS, (uint32_t)CCU4_CC4_PRS_PRS_Msk,\
	               (uint32_t)CCU4_CC4_PRS_PRS_Pos, (uint32_t)CNT001_MAX_EVENTS);

    /* Request SW shadow transfer */
    CCU4KernelPtr->GCSS |=
        (uint32_t)(((uint32_t)0x01 << ((uint32_t)4 * (uint32_t)HandlePtr->CCUInUse)) |
            ((uint32_t)0x01 << (((uint32_t)4 * (uint32_t)HandlePtr->CCUInUse) + 1U)) |
            ((uint32_t)0x01 << (((uint32_t)4 * (uint32_t)HandlePtr->CCUInUse) + 2U)));

    /* Clear all interrupts */
    CCU4Ptr->SWR = CNT001_ALL_CCU4_INTR_CLEAR;

    /* Enable configured interrupts */
    CCU4Ptr->INTE |= HandlePtr->InterruptControl;

    /*Initialize global variables */
    HandlePtr->DynamicHandlePtr->EvtCounterValue = 0x00U;
    HandlePtr->DynamicHandlePtr->NewCountMatch = HandlePtr->CountMatch;

    /* Set the App State to Initialized */
    HandlePtr->DynamicHandlePtr->State = CNT001_INITIALIZED;

    status = (uint32_t)DAVEApp_SUCCESS;
  }while(0);
  DBG002_FUNCTION_EXIT(APP_GID, (uint32_t)CNT001_FUNCTION_EXIT);
  return status;
}


/* This Function resets the CCU4_CCy slice and the app */
status_t CNT001_Deinit(const CNT001_HandleType *HandlePtr )
{
  status_t status = (uint32_t)CNT001_OPER_NOT_ALLOWED_ERROR;
  CCU4_CC4_TypeDef *CCU4Ptr;              /* Pointer to the CCU4 Register Set  */
  CCU4_GLOBAL_TypeDef *CCU4KernelPtr; /* Pointer to the CCU4 Kernel Register Set */
  CCU4Ptr = HandlePtr->CC4Ptr;
  CCU4KernelPtr = HandlePtr->CC4KernalPtr;


  DBG002_FUNCTION_ENTRY(APP_GID, (uint32_t)CNT001_FUNCTION_ENTRY);

    /*<<<DD_CNT001_API_2_1>>> */
    /* If current state is running, then stop the App first */
    if (HandlePtr->DynamicHandlePtr->State == CNT001_UNINITIALIZED)
    {
      DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, CNT001_STATUS_LEN, &status);
    }
    /*End of "if( HandlePtr->DynamicHandlePtr->State == CNT001_RUNNING )" */
    else
    {
    /* Clear the Run Bit  in TCCLR register */
    CCU4Ptr->TCCLR |= CNT001_CCU4_TCCLR_CLEAR;
    /* Clear  the Interrupts in SWR register */
    CCU4Ptr->SWR =  CNT001_ALL_CCU4_INTR_CLEAR ;
    /* Disable the Interrupts in INTE Register */
    CCU4Ptr->INTE = CNT001_CCUx_INTE_RESET;
    /*<<<DD_CNT001_API_2_2>>> */
    /* Set the  IDLE mode */
    CCU4KernelPtr->GIDLS |= (uint32_t)(((uint32_t)0x01 << \
	          ((uint32_t)CCU4_GIDLS_SS0I_Pos + (uint32_t)HandlePtr->CCUInUse)));
    /* Reset Input Selector Register */
    CCU4Ptr->INS = CNT001_CCUx_INS_RESET;
    /* Reset CMC Register */
    CCU4Ptr->CMC = CNT001_CCUx_CMC_RESET;
    /* Reset TC Register */
    CCU4Ptr->TC = CNT001_CCUx_TC_RESET;
    /* Reset CRS Register */
    CCU4Ptr->CRS =  CNT001_CCUx_CRS_RESET;
    /* Reset PRS Register */
    CCU4Ptr->PRS = CNT001_CCUx_PRS_RESET;
    /*Clear dynamic structure variables.*/
    HandlePtr->DynamicHandlePtr->EvtCounterValue = 0x00U;
    HandlePtr->DynamicHandlePtr->NewCountMatch  = 0x00U;
    /* Set the state to Uninitialized */
    HandlePtr->DynamicHandlePtr->State = CNT001_UNINITIALIZED;
    status = (uint32_t)DAVEApp_SUCCESS;
    }  
  DBG002_FUNCTION_EXIT(APP_GID, (uint32_t)CNT001_FUNCTION_EXIT);
  return status;
}

/* This Function starts the CCU4_CCy slice timer and starts the app. */
status_t  CNT001_Start(const CNT001_HandleType * HandlePtr )
{
  status_t status = (uint32_t)CNT001_OPER_NOT_ALLOWED_ERROR;
  CCU4_CC4_TypeDef *CCU4Ptr;              /* Pointer to the CCU4 Register set */

  CCU4_GLOBAL_TypeDef *CCU4KernelPtr; /* Pointer to the CCU4 Kernel Register set */
  CCU4Ptr = HandlePtr->CC4Ptr;
  CCU4KernelPtr = HandlePtr->CC4KernalPtr;

  DBG002_FUNCTION_ENTRY(APP_GID, (uint32_t)CNT001_FUNCTION_ENTRY);

  /*<<<DD_CNT001_API_3_1>>> */
    if (HandlePtr->DynamicHandlePtr->State != CNT001_INITIALIZED)
    {
      DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, CNT001_STATUS_LEN, &status);
    }/*End of "if( HandlePtr->DynamicHandlePtr->State != CNT001_INITIALIZED )" */
    else
    {
    /*<<<DD_CNT001_API_3_2>>> */
    /* Clear IDLE mode. */
    SET_BIT(CCU4KernelPtr->GIDLC,
        ((uint32_t)CCU4_GIDLC_CS0I_Pos + (uint32_t)HandlePtr->CCUInUse));

    /* Set the Run bit of the Slice in TCSET Register */
    SET_BIT( CCU4Ptr->TCSET,CCU4_CC4_TCSET_TRBS_Pos );

    /* Set the App State to Running State */
    HandlePtr->DynamicHandlePtr->State = CNT001_RUNNING;
    status = (uint32_t)DAVEApp_SUCCESS;
    }
  DBG002_FUNCTION_EXIT(APP_GID, (uint32_t)CNT001_FUNCTION_EXIT);
  return status;
}

/* This Function stops the CCU4_CCy slice timer and stops the app*/
status_t CNT001_Stop(const CNT001_HandleType *HandlePtr )
{
  status_t status = (uint32_t)CNT001_OPER_NOT_ALLOWED_ERROR;
  CCU4_CC4_TypeDef *CCU4Ptr;              /* Pointer to the CCU4 Register set */

  CCU4_GLOBAL_TypeDef *CCU4KernelPtr; /* Pointer to the CCU4 Kernel Register set */
  CCU4Ptr = HandlePtr->CC4Ptr;
  CCU4KernelPtr = HandlePtr->CC4KernalPtr;
  DBG002_FUNCTION_ENTRY(APP_GID, (uint32_t)CNT001_FUNCTION_ENTRY);

    /*<<<DD_CNT001_API_4_1>>>*/
    if (HandlePtr->DynamicHandlePtr->State != CNT001_RUNNING)
    {
      DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, CNT001_STATUS_LEN, &status);
    }
    else
    {
    /*<<<DD_CNT001_API_4_2>>>*/
    /* Clear the Run Bit  in TCCLR register */
    CCU4Ptr->TCCLR |= CNT001_CCU4_TCCLR_CLEAR;
    /* Clear  the Interrupts in SWR register */
    CCU4Ptr->SWR =  CNT001_ALL_CCU4_INTR_CLEAR ;

    /* Set the  IDLE mode in GIDLS Register */
    CCU4KernelPtr->GIDLS |= (uint32_t)(((uint32_t)0x01 << \
	          ((uint32_t)CCU4_GIDLS_SS0I_Pos + (uint32_t)HandlePtr->CCUInUse)));

    HandlePtr->DynamicHandlePtr->EvtCounterValue = 0x00U;
    HandlePtr->DynamicHandlePtr->NewCountMatch  = 0x00U;
    HandlePtr->DynamicHandlePtr->State = CNT001_INITIALIZED;
    status = (uint32_t)DAVEApp_SUCCESS;
    }
  DBG002_FUNCTION_EXIT(APP_GID, (uint32_t)CNT001_FUNCTION_EXIT);
  return status;
}

/* This Function gets the timer count value which is the number of events counted till now */
status_t CNT001_GetEvtCountValue(const CNT001_HandleType *HandlePtr, uint32_t *NumEvents )
{
  status_t status = (uint32_t)CNT001_OPER_NOT_ALLOWED_ERROR;
  CCU4_CC4_TypeDef *CCU4Ptr;               /* Pointer to the CCU4 Register set */
  CCU4Ptr = HandlePtr->CC4Ptr;
  DBG002_FUNCTION_ENTRY(APP_GID, (uint32_t)CNT001_FUNCTION_ENTRY);
  
    /*<<<DD_CNT001_API_5_1>>>*/
    if (HandlePtr->DynamicHandlePtr->State == CNT001_UNINITIALIZED)
    {
      DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, CNT001_STATUS_LEN, &status);
    }
    else
    {
    *NumEvents = RD_REG(CCU4Ptr->TIMER, (uint32_t)CCU4_CC4_TIMER_TVAL_Msk,\
	                                         (uint32_t)CCU4_CC4_TIMER_TVAL_Pos);
    status = (uint32_t)DAVEApp_SUCCESS;
    }
  DBG002_FUNCTION_EXIT(APP_GID, (uint32_t)CNT001_FUNCTION_EXIT);
  return status;
}


/* This Function reads the Count Match value. At this value, compare match interrupt is generated
 *  if it is enabled */
status_t CNT001_GetCountMatch(const CNT001_HandleType *HandlePtr, uint32_t* CompRegVal)
{
  status_t status = (uint32_t)CNT001_OPER_NOT_ALLOWED_ERROR;
  DBG002_FUNCTION_ENTRY(APP_GID, (uint32_t)CNT001_FUNCTION_ENTRY);

    /*<<<DD_CNT001_API_6_1>>>  */
    if (HandlePtr->DynamicHandlePtr->State == CNT001_UNINITIALIZED)
    {
      DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, CNT001_STATUS_LEN, &status);
    }
    else
    {
    /*<<<DD_CNT001_API_6_2>>>  */
    *CompRegVal = HandlePtr->DynamicHandlePtr->NewCountMatch;
    status = (uint32_t)DAVEApp_SUCCESS;
    }
  DBG002_FUNCTION_EXIT(APP_GID, (uint32_t)CNT001_FUNCTION_EXIT);
  return status;
}

/* This Function sets the event Count Match. This is the compare register value of the CCU4x_CCy slice */
status_t CNT001_SetCountMatch(const CNT001_HandleType *HandlePtr, uint32_t CountMatch)
{
  status_t status = (uint32_t)CNT001_OPER_NOT_ALLOWED_ERROR;
  CCU4_CC4_TypeDef *CCU4Ptr;            /* Pointer to the CCU4 Register set */

  CCU4_GLOBAL_TypeDef *CCU4KernelPtr; /* Pointer to the CCU4 Kernel Register set */
  CCU4Ptr = HandlePtr->CC4Ptr;
  CCU4KernelPtr = HandlePtr->CC4KernalPtr;

  DBG002_FUNCTION_ENTRY(APP_GID, (uint32_t)CNT001_FUNCTION_ENTRY);

    /*<<<DD_CNT001_API_7_1>>>*/
    if (HandlePtr->DynamicHandlePtr->State != CNT001_INITIALIZED)
    {
      DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, CNT001_STATUS_LEN, &status);
    }
    else if( CountMatch > CNT001_EVENT_COUNT_MAX   )
    {
      status = (uint32_t)CNT001_OUT_OF_RANGE_ERROR;
    }
    else
    {
      /*<<<DD_CNT001_API_7_5>>>*/
      /* Update the Count match value in CRS Register */
      WR_REG(CCU4Ptr->CRS, (uint32_t)CCU4_CC4_CRS_CRS_Msk, \
	                                 (uint32_t)CCU4_CC4_CRS_CRS_Pos,CountMatch);
  
      /* Request SW Shadow Transfer */
      CCU4KernelPtr->GCSS |=
          (uint32_t)((0x01UL << ((uint32_t)4 * (uint32_t)HandlePtr->CCUInUse)));
  
      /* Update the Dynamic HandlePtr */
      HandlePtr->DynamicHandlePtr ->NewCountMatch = CountMatch;
      status = (uint32_t)DAVEApp_SUCCESS;
    }

  DBG002_FUNCTION_EXIT(APP_GID, (uint32_t)CNT001_FUNCTION_EXIT);
  return status;
}

/* This Function reads the timer status */
status_t  CNT001_GetTimerStatus(const CNT001_HandleType *HandlePtr, uint32_t* Status)
{
  status_t status = (uint32_t)CNT001_OPER_NOT_ALLOWED_ERROR;
  CCU4_CC4_TypeDef *CCU4Ptr;                 /* Pointer to the CCU4 Register set */
  CCU4Ptr = HandlePtr->CC4Ptr;

  DBG002_FUNCTION_ENTRY(APP_GID, (uint32_t)CNT001_FUNCTION_ENTRY);

    /*<<<DD_CNT001_API_8_1>>> */
    if (HandlePtr->DynamicHandlePtr->State == CNT001_UNINITIALIZED)
    {
      DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, CNT001_STATUS_LEN, &status);
    }
    else
    {
    /*<<<DD_CNT001_API_8_2>>> */
    /* Get the Status of the Timer */
    *Status = RD_REG( CCU4Ptr->TCST, (uint32_t)CCU4_CC4_TCST_TRB_Msk,\
	                                           (uint32_t)CCU4_CC4_TCST_TRB_Pos);
    status = (uint32_t)DAVEApp_SUCCESS;
    }
  DBG002_FUNCTION_EXIT(APP_GID, (uint32_t)CNT001_FUNCTION_EXIT);
  return status;
}

/* This function enables the given event */
status_t CNT001_EnableEvent
(
    const CNT001_HandleType * HandlePtr,
    const CNT001_EventNameType Event
)
{
  status_t Status =  (uint32_t)CNT001_OPER_NOT_ALLOWED_ERROR;
  CCU4_CC4_TypeDef* CC4yRegsPtr = HandlePtr->CC4Ptr;
  DBG002_FUNCTION_ENTRY(APP_GID, (uint32_t)CNT001_FUNCTION_ENTRY);

  if (HandlePtr->DynamicHandlePtr->State == CNT001_UNINITIALIZED)
  {
	DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, CNT001_STATUS_LEN, &status);
  }
  else
  {
    SET_BIT(CC4yRegsPtr->INTE, (uint8_t) Event);
    Status =  (uint32_t)DAVEApp_SUCCESS;
  }
  DBG002_FUNCTION_EXIT(APP_GID, (uint32_t)CNT001_FUNCTION_EXIT);
  return (Status);
}

/**
 * This function clears the enable event bit for the event given in the argument.
 */
status_t CNT001_DisableEvent
(
    const CNT001_HandleType * HandlePtr,
    const CNT001_EventNameType Event
)
{
  status_t Status = (uint32_t) CNT001_OPER_NOT_ALLOWED_ERROR;
  CCU4_CC4_TypeDef* CC4yRegsPtr = HandlePtr->CC4Ptr;
  DBG002_FUNCTION_ENTRY(APP_GID, (uint32_t)CNT001_FUNCTION_ENTRY);

  if (HandlePtr->DynamicHandlePtr->State == CNT001_UNINITIALIZED)
  {
	DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, CNT001_STATUS_LEN, &status);
  }
  else
  {
    CLR_BIT(CC4yRegsPtr->INTE, (uint8_t) Event);
    Status = (uint32_t) DAVEApp_SUCCESS;
  }
  DBG002_FUNCTION_EXIT(APP_GID, (uint32_t)CNT001_FUNCTION_EXIT);
  return (Status);
}

/**
 * This function clears the interrupt by software.
 */
status_t CNT001_ClearPendingEvent
(
    const CNT001_HandleType * HandlePtr,
    const CNT001_EventNameType Event
)
{
  status_t Status =  (uint32_t)CNT001_OPER_NOT_ALLOWED_ERROR;
  CCU4_CC4_TypeDef* CC4yRegsPtr = HandlePtr->CC4Ptr;
  DBG002_FUNCTION_ENTRY(APP_GID, (uint32_t)CNT001_FUNCTION_ENTRY);

  if (HandlePtr->DynamicHandlePtr->State == CNT001_UNINITIALIZED)
  {
	DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, CNT001_STATUS_LEN, &status);
  }
  else
  {
    SET_BIT(CC4yRegsPtr->SWR,  (uint8_t)Event);
    Status =  (uint32_t)DAVEApp_SUCCESS;
  }
  DBG002_FUNCTION_EXIT(APP_GID, (uint32_t)CNT001_FUNCTION_EXIT);
  return (Status);
}

/**
 * This function sets the interrupt by software Interrupt pulse is generated
 * if source is enabled.
 */
status_t CNT001_SetPendingEvent
(
    const CNT001_HandleType * HandlePtr,
    const CNT001_EventNameType Event
)
{
  status_t Status =  (uint32_t)CNT001_OPER_NOT_ALLOWED_ERROR;
  CCU4_CC4_TypeDef* CC4yRegsPtr = HandlePtr->CC4Ptr;
  DBG002_FUNCTION_ENTRY(APP_GID, (uint32_t)CNT001_FUNCTION_ENTRY);

  if (HandlePtr->DynamicHandlePtr->State == CNT001_UNINITIALIZED)
  {
	DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, CNT001_STATUS_LEN, &status);
  }
  else
  {
    SET_BIT(CC4yRegsPtr->SWS,  (uint8_t)Event);
    Status =  (uint32_t)DAVEApp_SUCCESS;
  }
  DBG002_FUNCTION_EXIT(APP_GID, (uint32_t)CNT001_FUNCTION_EXIT);
  return (Status);
}

/**
 * This function checks whether given interrupt is set
 */
status_t CNT001_GetPendingEvent
(
    const CNT001_HandleType * HandlePtr,
    const CNT001_EventNameType Event,
    uint8_t* EvtStatus
)
{
  status_t Status =  (uint32_t)CNT001_OPER_NOT_ALLOWED_ERROR;
  CCU4_CC4_TypeDef* CC4yRegsPtr = HandlePtr->CC4Ptr;
  DBG002_FUNCTION_ENTRY(APP_GID, (uint32_t)CNT001_FUNCTION_ENTRY);

  if (HandlePtr->DynamicHandlePtr->State == CNT001_UNINITIALIZED)
  {
	 DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, CNT001_STATUS_LEN, &status);
  }
  else
  {
    if(RD_REG(CC4yRegsPtr->INTS, ((uint32_t)0x01<<(uint8_t)Event),(uint8_t)Event))
    {
      *EvtStatus = (uint8_t)SET;
    }
    else
    {
      *EvtStatus = (uint8_t)RESET;
    }
    /* *EvtStatus = RD_REG(CC4yRegsPtr->INTS,  (0x01<<(uint8_t)Event),(uint8_t)Event) ?\
	 (uint8_t)SET : (uint8_t)RESET;	*/
    Status =  (uint32_t)DAVEApp_SUCCESS;
  }
  DBG002_FUNCTION_EXIT(APP_GID, (uint32_t)CNT001_FUNCTION_EXIT);
  return (Status);
}

/**
 * This function resets the timer to zero.
 */
status_t CNT001_ResetCounter
(
    const CNT001_HandleType * HandlePtr
)
{
  status_t Status =  (uint32_t)CNT001_OPER_NOT_ALLOWED_ERROR;
  CCU4_CC4_TypeDef* CC4yRegsPtr = HandlePtr->CC4Ptr;
  DBG002_FUNCTION_ENTRY(APP_GID, (uint32_t)CNT001_FUNCTION_ENTRY);
  /* This function is not allowed in the UNINITIALIZED state */
  if (HandlePtr->DynamicHandlePtr->State == CNT001_UNINITIALIZED)
  {
	DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, CNT001_STATUS_LEN, &status);
  }
  /* Clear the timer in TCCLR register */
  else
  {
    CC4yRegsPtr->TCCLR |=  CNT001_CLEAR_COUNTER;
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  DBG002_FUNCTION_EXIT(APP_GID, (uint32_t)CNT001_FUNCTION_EXIT);
  return (Status);

}


/**
 * @endcond
 */
/*CODE_BLOCK_END*/

